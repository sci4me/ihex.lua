==============================================================================================================================================
Hits Total  Self Child Line | ./src/lua-ihex.lua - Times in milliseconds
----------------------------------------------------------------------------------------------------------------------------------------------
   .     .     .     .    1 | --- Intel Hex encoder/decoder.
   .     .     .     .    2 | --
   .     .     .     .    3 | -- An opinionated, mostly-feature-complete,
   .     .     .     .    4 | -- probably-not-that-buggy Intel Hex encoding
   .     .     .     .    5 | -- and decoding utility library for Lua.
   .     .     .     .    6 | --
   .     .     .     .    7 | -- `lua-ihex` only has one dependency: `bit32`.
   .     .     .     .    8 | -- Support for using `lua-ihex` without `bit32`
   .     .     .     .    9 | -- may be added in the future.
   .     .     .     .   10 | --
   .     .     .     .   11 | -- @module lua-ihex
   .     .     .     .   12 | -- @author sci4me
   .     .     .     .   13 | -- @license MIT
   .     .     .     .   14 | -- @copyright Scitoshi Nakayobro 2021
   .     .     .     .   15 | 
   .     .     .     .   16 | local bit
   1  0.41  0.41  0.00   17 | if jit then
   .     .     .     .   18 |     bit = require "bit"
   .     .     .     .   19 | else
   1  0.09  0.09  0.00   20 |     bit = require "bit32"
   .     .     .     .   21 | end
   .     .     .     .   22 | 
   1  0.00  0.00  0.00   23 | local band   = bit.band
   1  0.00  0.00  0.00   24 | local lshift = bit.lshift
   1  0.00  0.00  0.00   25 | local rshift = bit.rshift
   1  0.00  0.00  0.00   26 | local strfmt = string.format
   1  0.00  0.00  0.00   27 | local substr = string.sub
   .     .     .     .   28 | 
   1  0.00  0.00  0.00   29 | local HEX_DECODE_LUT = {
   1  0.00  0.00  0.00   30 |     ['0'] = 0x0, ['1'] = 0x1, ['2'] = 0x2, ['3'] = 0x3,
   1  0.00  0.00  0.00   31 |     ['4'] = 0x4, ['5'] = 0x5, ['6'] = 0x6, ['7'] = 0x7,
   1  0.00  0.00  0.00   32 |     ['8'] = 0x8, ['9'] = 0x9, ['a'] = 0xA, ['A'] = 0xA,
   1  0.00  0.00  0.00   33 |     ['b'] = 0xB, ['B'] = 0xB, ['c'] = 0xC, ['C'] = 0xC,
   1  0.00  0.00  0.00   34 |     ['d'] = 0xD, ['D'] = 0xD, ['e'] = 0xE, ['E'] = 0xE,
   1  0.00  0.00  0.00   35 |     ['f'] = 0xF, ['F'] = 0xF
   .     .     .     .   36 | }
   .     .     .     .   37 | 
   1  0.00  0.00  0.00   38 | local REC_DATA                     = 0x00
   1  0.00  0.00  0.00   39 | local REC_EOF                      = 0x01
   1  0.00  0.00  0.00   40 | local REC_EXTENDED_SEGMENT_ADDRESS = 0x02
   1  0.00  0.00  0.00   41 | local REC_START_SEGMENT_ADDRESS    = 0x03
   1  0.00  0.00  0.00   42 | local REC_EXTENDED_LINEAR_ADDRESS  = 0x04
   1  0.00  0.00  0.00   43 | local REC_START_LINEAR_ADDRESS     = 0x05
   .     .     .     .   44 | 
8890  2.33  2.33  0.00   45 | -- Function totals
   .     .     .     .   45 | local function is_int(x)
8890  2.33  2.33  0.00   46 |     return x == math.floor(x)
   1  0.00  0.00  0.00   47 | end
   .     .     .     .   48 | 
 240  0.04  0.04  0.00   49 | -- Function totals
   .     .     .     .   49 | local function is_newline(c)
 240  0.04  0.04  0.00   50 |     return c == '\r' or c == '\n'
   1  0.00  0.00  0.00   51 | end
   .     .     .     .   52 | 
 100  0.02  0.02  0.00   53 | -- Function totals
   .     .     .     .   53 | local function option(opts, name, defaults)
 100  0.02  0.02  0.00   54 |     return opts[name] and opts[name] or defaults[name]
   1  0.00  0.00  0.00   55 | end
   .     .     .     .   56 | 
   .     .     .     .   57 | --- Default decoding options to be used
   .     .     .     .   58 | -- if no options are specified for the
   .     .     .     .   59 | -- `decode` function.
   .     .     .     .   60 | -- @table DEFAULT_DECODE_OPTIONS
   .     .     .     .   61 | -- @field[opt=false] skipNonColonLines If set to true, `decode`
   .     .     .     .   62 | -- will ignore lines that do not begin with a `:`
   .     .     .     .   63 | -- @field[opt=false] allowOverwrite If set to true, `decode`
   .     .     .     .   64 | -- will not raise an error if the parsed Intel Hex
   .     .     .     .   65 | -- data specifies a data byte at the same address
   .     .     .     .   66 | -- multiple times.
   .     .     .     .   67 | -- @field[opt=true] allowExtendedSegmentAddress If set to true,
   .     .     .     .   68 | -- `decode` will not raise an error if the parsed
   .     .     .     .   69 | -- Intel Hex data contains an extended segment address
   .     .     .     .   70 | -- record.
   .     .     .     .   71 | -- @field[opt=false] allowStartSegmentAddress If set to true,
   .     .     .     .   72 | -- `decode` will not raise an error if the parsed
   .     .     .     .   73 | -- Intel Hex data contains a start segment address
   .     .     .     .   74 | -- record.
   .     .     .     .   75 | -- @field[opt=true] allowExtendedLinearAddress If set to true,
   .     .     .     .   76 | -- `decode` will not raise an error if the parsed
   .     .     .     .   77 | -- Intel Hex data contains an extended linear address
   .     .     .     .   78 | -- record.
   .     .     .     .   79 | -- @field[opt=false] allowStartLinearAddress If set to true,
   .     .     .     .   80 | -- `decode` will not raise an error if the parsed
   .     .     .     .   81 | -- Intel Hex data contains a start linear address
   .     .     .     .   82 | -- record.
   1  0.00  0.00  0.00   83 | local DEFAULT_DECODE_OPTIONS = {
   1  0.00  0.00  0.00   84 |     skipNonColonLines              = false,
   1  0.00  0.00  0.00   85 |     allowOverwrite                 = false,
   1  0.00  0.00  0.00   86 |     allowExtendedSegmentAddress    = true,
   1  0.00  0.00  0.00   87 |     allowStartSegmentAddress       = false,
   1  0.00  0.00  0.00   88 |     allowExtendedLinearAddress     = true,
   1  0.00  0.00  0.00   89 |     allowStartLinearAddress        = false
   .     .     .     .   90 | }
   .     .     .     .   91 | 
   .     .     .     .   92 | --- Default encoding options to be used
   .     .     .     .   93 | -- if no options are specified for the
   .     .     .     .   94 | -- `encode` function.
   .     .     .     .   95 | -- @table DEFAULT_ENCODE_OPTIONS
   .     .     .     .   96 | -- @field[opt=0x20] bytesPerLine The maximum
   .     .     .     .   97 | -- number of bytes to be encoded per line.
   .     .     .     .   98 | -- @field[opt=true] upperCaseHex If set to true,
   .     .     .     .   99 | -- `encode` will use upper-case hex digits.
   .     .     .     .  100 | -- @field[opt=false] crlf If set to true,
   .     .     .     .  101 | -- `encode` will use Windows-style line breaks
   .     .     .     .  102 | -- (`\r\n`). Otherwise, the correct style of line
   .     .     .     .  103 | -- break will be used (`\n`).
   .     .     .     .  104 | -- @field[opt=false] lineBreaksAtEndOfFile If set
   .     .     .     .  105 | -- to true, `encode` will insert a line break after
   .     .     .     .  106 | -- the last line (EOF record).
   1  0.00  0.00  0.00  107 | local DEFAULT_ENCODE_OPTIONS = {
   1  0.00  0.00  0.00  108 |     bytesPerLine                   = 0x20,
   1  0.00  0.00  0.00  109 |     upperCaseHex                   = true,
   1  0.00  0.00  0.00  110 |     crlf                           = false,
   1  0.00  0.00  0.00  111 |     lineBreakAtEndOfFile           = false
   .     .     .     .  112 | }
   .     .     .     .  113 | 
   .     .     .     .  114 | --- Decode an Intel Hex encoded string to a byte array.
   .     .     .     .  115 | -- The returned table is an array of decoded bytes,
   .     .     .     .  116 | -- which may or may not be contiguous. Intel Hex allows
   .     .     .     .  117 | -- for specifying disjoint blocks of data, therefore,
   .     .     .     .  118 | -- there may be indices between blocks of valid data
   .     .     .     .  119 | -- that have the value `nil`.
   .     .     .     .  120 | --
   .     .     .     .  121 | -- The first index that may contain data is `0`. Since
   .     .     .     .  122 | -- Lua made the mistake of using `1`-based indexing,
   .     .     .     .  123 | -- the length of the table will be off by one.
   .     .     .     .  124 | -- Therefore, the resultant table will also contain
   .     .     .     .  125 | -- the field `count` which contains the number of data
   .     .     .     .  126 | -- bytes specified by the input string.
   .     .     .     .  127 | --
   .     .     .     .  128 | -- This function allows an optional second argument
   .     .     .     .  129 | -- which must be a table containing options specifying
   .     .     .     .  130 | -- how the input string should be interpreted.
   .     .     .     .  131 | -- If no second argument is specified, the default
   .     .     .     .  132 | -- options (`DEFAULT_DECODE_OPTIONS`) will be used.
   .     .     .     .  133 | --
   .     .     .     .  134 | -- This function can optionally handle the
   .     .     .     .  135 | -- start segment address and start linear address
   .     .     .     .  136 | -- Intel Hex record types.
   .     .     .     .  137 | --
   .     .     .     .  138 | -- If start segment address records are enabled in
   .     .     .     .  139 | -- the options table and the input string contains
   .     .     .     .  140 | -- such a record, the table indices `CS` and `IP` will
   .     .     .     .  141 | -- be set.
   .     .     .     .  142 | -- To enable start segment address records, set
   .     .     .     .  143 | -- `allowStartSegmentAddress` to true in the options
   .     .     .     .  144 | -- table.
   .     .     .     .  145 | --
   .     .     .     .  146 | -- If start linear address records are enabled in
   .     .     .     .  147 | -- the options table and the input string contains
   .     .     .     .  148 | -- such a record, the table index `EIP` will be set.
   .     .     .     .  149 | -- To enable start linear address records, set
   .     .     .     .  150 | -- `allowStartLinearAddress` to true in the options
   .     .     .     .  151 | -- table.
   .     .     .     .  152 | --
   .     .     .     .  153 | -- @tparam string str A string containing data encoded
   .     .     .     .  154 | -- in the Intel Hex format.
   .     .     .     .  155 | -- @tparam[opt] table options A table specifying how the input
   .     .     .     .  156 | -- string should be interpreted. see @{DEFAULT_DECODE_OPTIONS}
   .     .     .     .  157 | -- @treturn table A table containing each data byte specified
   .     .     .     .  158 | -- by the input string, indexed by its respective numeric address.
   .     .     .     .  159 | -- This table also contains the field `count` which is the
   .     .     .     .  160 | -- total number of data bytes decoded from the input string.
  10 12.27  5.39  6.88  161 | -- Function totals
   .     .     .     .  161 | local function decode(str, options)
  10  0.00  0.00  0.00  162 |     if options then
   .     .     .     .  163 |         assert(type(options) == "table", "expected table, got " .. type(options))
   .     .     .     .  164 |     else
  10  0.00  0.00  0.00  165 |         options = {}
   .     .     .     .  166 |     end
   .     .     .     .  167 | 
  10  0.00  0.00  0.00  168 |     local skipNonColonLines           = option(options, "skipNonColonLines", DEFAULT_DECODE_OPTIONS)
  10  0.00  0.00  0.00  169 |     local allowOverwrite              = option(options, "allowOverwrite", DEFAULT_DECODE_OPTIONS)
  10  0.00  0.00  0.00  170 |     local allowExtendedSegmentAddress = option(options, "allowExtendedSegmentAddress", DEFAULT_DECODE_OPTIONS)
  10  0.00  0.00  0.00  171 |     local allowStartSegmentAddress    = option(options, "allowStartSegmentAddress", DEFAULT_DECODE_OPTIONS)
  10  0.00  0.00  0.00  172 |     local allowExtendedLinearAddress  = option(options, "allowExtendedLinearAddress", DEFAULT_DECODE_OPTIONS)
  10  0.00  0.00  0.00  173 |     local allowStartLinearAddress     = option(options, "allowStartLinearAddress", DEFAULT_DECODE_OPTIONS)
   .     .     .     .  174 | 
  10  0.00  0.00  0.00  175 |     local index = 1
  10  0.00  0.00  0.00  176 |     local len   = str:len()
  10  0.00  0.00  0.00  177 |     local sum   = 0
   .     .     .     .  178 | 
 490  0.21  0.21  0.00  179 | -- Function totals
   .     .     .     .  179 |     local function next()
 490  0.06  0.06  0.00  180 |         if index > len then error("unexpected end of data") end
 490  0.11  0.11  0.00  181 |         local c = substr(str, index, index)
 490  0.02  0.02  0.00  182 |         index = index + 1
 490  0.02  0.02  0.00  183 |         return c
  10  0.00  0.00  0.00  184 |     end
   .     .     .     .  185 | 
 240  0.27  0.14  0.14  186 | -- Function totals
   .     .     .     .  186 |     local function skip_newline()
 240  0.14  0.04  0.10  187 |         local a = next()
 240  0.11  0.08  0.04  188 |         assert(is_newline(a), "expected line feed or carriage return")
 240  0.01  0.01  0.00  189 |         if a == '\r' and substr(str, index, index) == '\n' then
   .     .     .     .  190 |             index = index + 1
   .     .     .     .  191 |         end
 250  0.01  0.01  0.00  192 |     end
   .     .     .     .  193 | 
8430  6.01  6.01  0.00  194 | -- Function totals
   .     .     .     .  194 |     local function u1()
8430  1.03  1.03  0.00  195 |         if index + 1 > len then error("unexpected end of data") end
8430  3.71  3.71  0.00  196 |         local y = tonumber(substr(str, index, index + 1), 16)
8430  0.50  0.50  0.00  197 |         index = index + 2
8430  0.44  0.44  0.00  198 |         sum = sum + y
8430  0.34  0.34  0.00  199 |         return y
  10  0.00  0.00  0.00  200 |     end
   .     .     .     .  201 | 
 250  0.36  0.36  0.00  202 | -- Function totals
   .     .     .     .  202 |     local function u2()
   .     .     .     .  203 |         -- TODO: Can this somehow be further optimized?
 250  0.03  0.03  0.00  204 |         if index + 3 > len then error("unexpected end of data") end
 250  0.12  0.12  0.00  205 |         local hi = tonumber(substr(str, index, index + 1), 16)
 250  0.11  0.11  0.00  206 |         local lo = tonumber(substr(str, index + 2, index + 3), 16)
 250  0.01  0.01  0.00  207 |         index = index + 4
 250  0.01  0.01  0.00  208 |         sum = sum + hi
 250  0.01  0.01  0.00  209 |         sum = sum + lo
 250  0.07  0.07  0.00  210 |         return lshift(hi, 8) + lo
  10  0.00  0.00  0.00  211 |     end
   .     .     .     .  212 | 
 240  0.29  0.12  0.17  213 | -- Function totals
   .     .     .     .  213 |     local function verify_checksum()
 240  0.07  0.07  0.00  214 |         local computed_checksum = band(0x100 - sum, 0xFF)
 240  0.20  0.03  0.17  215 |         local checksum = u1()
 240  0.01  0.01  0.00  216 |         if computed_checksum ~= checksum then
   .     .     .     .  217 |             error(strfmt("bad checksum; expected %02X, got %02X", checksum, computed_checksum))
   .     .     .     .  218 |         end
 250  0.01  0.01  0.00  219 |     end
   .     .     .     .  220 | 
  10  0.00  0.00  0.00  221 |     local result = {}
  10  0.00  0.00  0.00  222 |     local count = 0
  10  0.00  0.00  0.00  223 |     local base = 0
  10  0.00  0.00  0.00  224 |     local eof = false
   .     .     .     .  225 | 
 250  0.02  0.02  0.00  226 |     while index <= len do
 250  0.01  0.01  0.00  227 |         local skip = false
 250  0.14  0.03  0.11  228 |         local sc = next()
 250  0.01  0.01  0.00  229 |         if sc ~= ':' then
   .     .     .     .  230 |             if skipNonColonLines then
   .     .     .     .  231 |                 while index <= len and not is_newline(substr(str, index, index)) do
   .     .     .     .  232 |                     index = index + 1
   .     .     .     .  233 |                 end
   .     .     .     .  234 |                 skip_newline()
   .     .     .     .  235 |                 skip = true
   .     .     .     .  236 |             else
   .     .     .     .  237 |                 if sc == '\r' then
   .     .     .     .  238 |                     sc = "\\r"
   .     .     .     .  239 |                 elseif sc == '\n' then
   .     .     .     .  240 |                     sc = "\\n"
   .     .     .     .  241 |                 end
   .     .     .     .  242 |                 error("expected : at beginning of line, got '" .. sc .. "'")
   .     .     .     .  243 |             end
   .     .     .     .  244 |         end
   .     .     .     .  245 | 
 250  0.01  0.01  0.00  246 |         if not skip then
 250  0.01  0.01  0.00  247 |             sum = 0
   .     .     .     .  248 |             -- TODO: Would be interesting to see how the profiling results
   .     .     .     .  249 |             -- compare between doing u1, u2, u1 vs. doing u4 and then using
   .     .     .     .  250 |             -- bit to pull the separate data fields out of the 32-bit number.
 250  0.22  0.03  0.19  251 |             local nbytes = u1()
 250  0.39  0.03  0.36  252 |             local addr = u2()
 250  0.21  0.03  0.18  253 |             local type = u1()
   .     .     .     .  254 | 
 250  0.01  0.01  0.00  255 |             if type == REC_DATA then
7920  0.36  0.36  0.00  256 |                 for i = 0, nbytes-1 do
7680  1.59  1.59  0.00  257 |                     local actual_addr = base + band(addr + i, 0xFFFF)
7680  6.38  0.92  5.46  258 |                     local x = u1()
7680  0.53  0.53  0.00  259 |                     if not allowOverwrite and result[actual_addr] then
   .     .     .     .  260 |                         error(strfmt("unexpected overwrite at address %08X", actual_addr))
   .     .     .     .  261 |                     end
7680  1.29  1.29  0.00  262 |                     result[actual_addr] = x
7680  0.35  0.35  0.00  263 |                     count = count + 1
 240  0.01  0.01  0.00  264 |                 end
  10  0.00  0.00  0.00  265 |             elseif type == REC_EOF then
  10  0.01  0.00  0.01  266 |                 local checksum = u1()
  10  0.01  0.01  0.00  267 |                 assert(checksum == 0xFF, "expected checksum of EOF record to be 0xFF, got " .. checksum)
  10  0.00  0.00  0.00  268 |                 eof = true
  10  0.00  0.00  0.00  269 |                 break
   .     .     .     .  270 |             elseif type == REC_EXTENDED_SEGMENT_ADDRESS then
   .     .     .     .  271 |                 assert(allowExtendedSegmentAddress, "unexpected extended segment address record")
   .     .     .     .  272 |                 assert(nbytes == 2, "extended segment address record must contain 2 bytes, got " .. nbytes)
   .     .     .     .  273 |                 base = lshift(u2(), 4)
   .     .     .     .  274 |             elseif type == REC_START_SEGMENT_ADDRESS then
   .     .     .     .  275 |                 assert(allowStartSegmentAddress, "unexpected start segment address record")
   .     .     .     .  276 |                 assert(addr == 0, strfmt("start segment address record address must be 0x0000, got %04X", addr))
   .     .     .     .  277 |                 assert(nbytes == 4, "start segment address record must contain 4 bytes, got " .. nbytes)
   .     .     .     .  278 |                 result.CS = u2()
   .     .     .     .  279 |                 result.IP = u2()
   .     .     .     .  280 |             elseif type == REC_EXTENDED_LINEAR_ADDRESS then
   .     .     .     .  281 |                 assert(allowExtendedLinearAddress, "unexpected extended linear address record")
   .     .     .     .  282 |                 assert(nbytes == 2, "extended linear address record must contain 2 bytes, got " .. nbytes)
   .     .     .     .  283 |                 base = lshift(u2(), 16)
   .     .     .     .  284 |             elseif type == REC_START_LINEAR_ADDRESS then
   .     .     .     .  285 |                 assert(allowStartLinearAddress, "unexpected start linear address record")
   .     .     .     .  286 |                 assert(addr == 0, strfmt("start linear address record address must be 0x0000, got %04X", addr))
   .     .     .     .  287 |                 assert(nbytes == 4, "start linear address record must contain 4 bytes, got " .. nbytes)
   .     .     .     .  288 |                 result.EIP = lshift(u2(), 16) + u2()
   .     .     .     .  289 |             else
   .     .     .     .  290 |                 error(strfmt("unexpected record type %02X", type))
   .     .     .     .  291 |             end
   .     .     .     .  292 | 
 240  0.32  0.03  0.29  293 |             verify_checksum()
 240  0.30  0.03  0.27  294 |             skip_newline()
 240  0.01  0.01  0.00  295 |         end
   .     .     .     .  296 |     end
   .     .     .     .  297 | 
  10  0.00  0.00  0.00  298 |     assert(eof, "unexpected end of data; expected EOF record")
   .     .     .     .  299 | 
  10  0.01  0.01  0.00  300 |     result.count = count
  10  0.00  0.00  0.00  301 |     return result
   1  0.00  0.00  0.00  302 | end
   .     .     .     .  303 | 
   .     .     .     .  304 | --- Encode a byte array in the Intel Hex format.
   .     .     .     .  305 | -- Unlike the `decode` function, `encode` uses `1`-based indexing!
   .     .     .     .  306 | -- In the future, support may be added to allow for the correct
   .     .     .     .  307 | -- indexing style to be used.
   .     .     .     .  308 | --
   .     .     .     .  309 | -- This function will encode a byte array starting at index `1`
   .     .     .     .  310 | -- and ending at index `#data` in the Intel Hex format and return
   .     .     .     .  311 | -- it as a string.
   .     .     .     .  312 | --
   .     .     .     .  313 | -- Currently `lua-ihex` does not support encoding disjoint blocks
   .     .     .     .  314 | -- of data, as well as start segment address and start linear address
   .     .     .     .  315 | -- records. Support for these features may be added in the future.
   .     .     .     .  316 | --
   .     .     .     .  317 | -- This function allows an optional second argument which must be
   .     .     .     .  318 | -- a table containing options specifying how the input data
   .     .     .     .  319 | -- should be encoded.
   .     .     .     .  320 | -- If no second argument is specified, the default options
   .     .     .     .  321 | -- (`DEFAULT_ENCODE_OPTIONS`) will be used.
   .     .     .     .  322 | --
   .     .     .     .  323 | -- @tparam table data An array of unsigned bytes to encode.
   .     .     .     .  324 | -- @tparam[opt] table options A table specifying how the input
   .     .     .     .  325 | -- data should be encoded.
   .     .     .     .  326 | -- @treturn string The Intel Hex encoded representation of the
   .     .     .     .  327 | -- input byte array.
  10 21.14  3.01 18.12  328 | -- Function totals
   .     .     .     .  328 | local function encode(data, options)
  10  0.01  0.01  0.00  329 |     if type(data) ~= "table" then
   .     .     .     .  330 |         error("expected table, got " .. type(data))
   .     .     .     .  331 |     end
   .     .     .     .  332 | 
  10  0.00  0.00  0.00  333 |     if options then
   .     .     .     .  334 |         assert(type(options) == "table", "expected table, got " .. type(options))
   .     .     .     .  335 |     else
  10  0.00  0.00  0.00  336 |         options = {}
   .     .     .     .  337 |     end
   .     .     .     .  338 | 
  10  0.00  0.00  0.00  339 |     local bytesPerLine         = option(options, "bytesPerLine", DEFAULT_ENCODE_OPTIONS)
  10  0.00  0.00  0.00  340 |     local upperCaseHex         = option(options, "upperCaseHex", DEFAULT_ENCODE_OPTIONS)
  10  0.00  0.00  0.00  341 |     local crlf                 = option(options, "crlf", DEFAULT_ENCODE_OPTIONS)
  10  0.00  0.00  0.00  342 |     local lineBreakAtEndOfFile = option(options, "lineBreakAtEndOfFile", DEFAULT_ENCODE_OPTIONS)
   .     .     .     .  343 | 
  10  0.00  0.00  0.00  344 |     local line_break = crlf and "\r\n" or "\n"
  10  0.00  0.00  0.00  345 |     local u1format   = upperCaseHex and "%02X" or "%02x"
   .     .     .     .  346 | 
  10  0.01  0.01  0.00  347 |     assert(is_int(bytesPerLine), "bytesPerLine must be an integer, got " .. tostring(bytesPerLine))
  10  0.00  0.00  0.00  348 |     assert(bytesPerLine >= 1, "bytesPerLine must be >= 1")
  10  0.00  0.00  0.00  349 |     assert(bytesPerLine <= 255, "bytesPerLine must be <= 255")
   .     .     .     .  350 | 
  10  0.00  0.00  0.00  351 |     local result = {}
  10  0.00  0.00  0.00  352 |     local sum = 0
  10  0.00  0.00  0.00  353 |     local index = 1
  10  0.00  0.00  0.00  354 |     local bytesLeft = #data
  10  0.00  0.00  0.00  355 |     local addr = 0
  10  0.00  0.00  0.00  356 |     local upper = 0
   .     .     .     .  357 | 
9370  2.84  2.84  0.00  358 | -- Function totals
   .     .     .     .  358 |     local function emit(x)
9370  2.44  2.44  0.00  359 |         result[#result + 1] = x
9380  0.41  0.41  0.00  360 |     end
   .     .     .     .  361 | 
8880 17.67 12.61  5.06  362 | -- Function totals
   .     .     .     .  362 |     local function u1(x)
8880  5.10  2.78  2.33  363 |         assert(is_int(x))
8880  1.53  1.53  0.00  364 |         assert(x >= 0)
8880  1.49  1.49  0.00  365 |         assert(x <= 255)
8880  8.63  5.90  2.73  366 |         emit(strfmt(u1format, x))
8880  0.57  0.57  0.00  367 |         sum = sum + x
8890  0.36  0.36  0.00  368 |     end
   .     .     .     .  369 | 
 240  1.13  0.19  0.94  370 | -- Function totals
   .     .     .     .  370 |     local function u2(x)
 240  0.59  0.11  0.48  371 |         u1(rshift(band(x, 0xFF00), 8))
 240  0.53  0.07  0.46  372 |         u1(band(x, 0xFF))
 250  0.01  0.01  0.00  373 |     end
   .     .     .     .  374 | 
 240  0.60  0.15  0.45  375 | -- Function totals
   .     .     .     .  375 |     local function write_checksum()
 240  0.57  0.13  0.45  376 |         u1(band(0x100 - sum, 0xFF))
 240  0.01  0.01  0.00  377 |         sum = 0
 250  0.01  0.01  0.00  378 |     end
   .     .     .     .  379 | 
 250  0.01  0.01  0.00  380 |     while bytesLeft > 0 do
 240  0.10  0.10  0.00  381 |         local up = rshift(band(addr, 0xFFFF0000), 16)
 240  0.02  0.02  0.00  382 |         if up ~= upper then
   .     .     .     .  383 |             upper = up
   .     .     .     .  384 | 
   .     .     .     .  385 |             emit(':')
   .     .     .     .  386 |             u1(2)
   .     .     .     .  387 |             u2(0)
   .     .     .     .  388 |             u1(REC_EXTENDED_LINEAR_ADDRESS)
   .     .     .     .  389 |             u2(up)
   .     .     .     .  390 |             write_checksum()
   .     .     .     .  391 |             emit(line_break)
   .     .     .     .  392 |         end
   .     .     .     .  393 | 
 240  0.09  0.03  0.05  394 |         emit(':')
   .     .     .     .  395 | 
 240  0.06  0.06  0.00  396 |         local nbytes = math.min(bytesPerLine, bytesLeft)
 240  0.53  0.03  0.50  397 |         u1(nbytes)
   .     .     .     .  398 | 
 240  1.20  0.08  1.13  399 |         u2(band(addr, 0xFFFF))
   .     .     .     .  400 | 
 240  0.52  0.03  0.49  401 |         u1(REC_DATA)
7920  0.34  0.34  0.00  402 |         for _ = 1, nbytes do
7680  0.43  0.43  0.00  403 |             local x = data[index]
7680  0.33  0.33  0.00  404 |             index = index + 1
7680 16.32  1.02 15.29  405 |             u1(x)
   .     .     .     .  406 |         end
 240  0.01  0.01  0.00  407 |         bytesLeft = bytesLeft - nbytes
 240  0.01  0.01  0.00  408 |         addr = addr + nbytes
   .     .     .     .  409 | 
 240  0.63  0.03  0.60  410 |         write_checksum()
 240  0.09  0.04  0.05  411 |         emit(line_break)
   .     .     .     .  412 |     end
   .     .     .     .  413 | 
  10  0.00  0.00  0.00  414 |     emit(":00000001FF")
   .     .     .     .  415 | 
  10  0.00  0.00  0.00  416 |     if lineBreakAtEndOfFile then
   .     .     .     .  417 |         emit(line_break)
   .     .     .     .  418 |     end
   .     .     .     .  419 | 
  10  0.38  0.38  0.00  420 |     return table.concat(result)
   1  0.00  0.00  0.00  421 | end
   .     .     .     .  422 | 
   .     .     .     .  423 | -- NOTE: Workaround to get LDoc not to complain about this; not sure what
   .     .     .     .  424 | -- the proper way to fix this would be; can't find an answer online. :/
   .     .     .     .  425 | local _LICENSE = [[
   .     .     .     .  426 |     MIT License
   .     .     .     .  427 | 
   .     .     .     .  428 |     Copyright (c) 2021 Scitoshi Nakayobro
   .     .     .     .  429 | 
   .     .     .     .  430 |     Permission is hereby granted, free of charge, to any person obtaining a copy
   .     .     .     .  431 |     of this software and associated documentation files (the "Software"), to deal
   .     .     .     .  432 |     in the Software without restriction, including without limitation the rights
   .     .     .     .  433 |     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   .     .     .     .  434 |     copies of the Software, and to permit persons to whom the Software is
   .     .     .     .  435 |     furnished to do so, subject to the following conditions:
   .     .     .     .  436 | 
   .     .     .     .  437 |     The above copyright notice and this permission notice shall be included in all
   .     .     .     .  438 |     copies or substantial portions of the Software.
   .     .     .     .  439 | 
   .     .     .     .  440 |     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   .     .     .     .  441 |     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   .     .     .     .  442 |     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   .     .     .     .  443 |     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   .     .     .     .  444 |     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   .     .     .     .  445 |     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   .     .     .     .  446 |     SOFTWARE.
   1  0.00  0.00  0.00  447 | ]]
   .     .     .     .  448 | 
   .     .     .     .  449 | --- @export DEFAULT_DECODE_OPTIONS
   .     .     .     .  450 | -- @export DEFAULT_ENCODE_OPTIONS
   .     .     .     .  451 | -- @export decode
   .     .     .     .  452 | -- @export encode
   1  0.00  0.00  0.00  453 | return {
   1  0.00  0.00  0.00  454 |     _DESCRIPTION           = "Intel Hex encoder/decoder",
   1  0.00  0.00  0.00  455 |     _URL                   = "https://github.com/sci4me/lua-ihex",
   1  0.00  0.00  0.00  456 |     _VERSION               = "lua-ihex 0.1.1",
   1  0.00  0.00  0.00  457 |     _LICENSE               = _LICENSE,
   1  0.00  0.00  0.00  458 |     DEFAULT_DECODE_OPTIONS = DEFAULT_DECODE_OPTIONS,
   1  0.00  0.00  0.00  459 |     DEFAULT_ENCODE_OPTIONS = DEFAULT_ENCODE_OPTIONS,
   1  0.00  0.00  0.00  460 |     decode                 = decode,
   1  0.00  0.00  0.00  461 |     encode                 = encode
   1  0.00  0.00  0.00  462 | }

==============================================================================================================================================
Hits Total  Self Child Line | perf_testing.lua - Times in milliseconds
----------------------------------------------------------------------------------------------------------------------------------------------
   1  0.52  0.00  0.51    1 | local ihex = require "src/lua-ihex"
   .     .     .     .    2 | 
   .     .     .     .    3 | 
   1  0.00  0.00  0.00    4 | local bit
   1  0.00  0.00  0.00    5 | if jit then
   .     .     .     .    6 |     bit = require "bit"
   .     .     .     .    7 | else
   1  0.00  0.00  0.00    8 |     bit = require "bit32"
   .     .     .     .    9 | end
   .     .     .     .   10 | 
   .     .     .     .   11 | 
   1  0.00  0.00  0.00   12 | local band = bit.band
   .     .     .     .   13 | 
   .     .     .     .   14 | 
  11  0.00  0.00  0.00   15 | for i = 1, 10 do
  10  0.00  0.00  0.00   16 |     local in_data = {}
7690  0.31  0.31  0.00   17 |     for j = 1, 0x300 do
7680  1.88  1.88  0.00   18 |         in_data[j] = band(j, 0xFF)
   .     .     .     .   19 |     end
   .     .     .     .   20 | 
  10 21.14  0.00 21.14   21 |     local hex = ihex.encode(in_data)
  10 12.27  0.00 12.27   22 |     local bin = ihex.decode(hex)
   .     .     .     .   23 | 
  10  0.00  0.00  0.00   24 |     assert(bin.count == #in_data)
   1  0.00  0.00  0.00   25 | end

